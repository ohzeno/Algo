# https://www.acmicpc.net/problem/15778
import sys
sys.stdin = open('input.txt')
def input():
    return sys.stdin.readline().rstrip()

"""
윷놀이. 윷가락 4개, 나/상대 말 각 4개, 윷판.
29개의 위치가 있고 이름이 붙어있다.
사진 1. 윷판(https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15778/yut.jpg)
네 개의 말을 처음 위치 우하단에서 시작해, 윷판을 돌아서 우하단으로 돌아온 이후 탈출하는 게임이다.
사진 2. 가능한 4가지 윷길(https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15778/yut2.jpg)
각 사람의 턴은 다음과 같이 진행된다.
- 윷을 던진다.
- 윷가락의 배치에 따라 전진할 칸 수를 정한다.
- 말을 정해서 전진한다.
윷가락 중 앞면의 개수가 전진하는 칸 수이다.
단, 모든 윷가락이 뒷면일 경우 5칸 전진한다.
전지하는 방향은 새로울 말일 경우 우하단에서 시작하는 것으로 생각하고 다음의 윷길을 따라 전진한다.
말을 움직일 때는 기본적으로 (사진 2)의 4번 윷길을 따라서 움직인다. 
예를 들면, 윷의 위치에서 두 칸 전진할 경우에 뒷도의 위치로 움직인다. 
하지만 특수한 경우에는 1번, 2번 혹은 3번 윷길을 따라서 움직인다. 
말이 움직이기 시작할 때 모서리 (좌상단, 우상단, 중앙, 쩔밭, 혹은 우하단)에 시작할 경우에는, 
우하단으로 가는 거리가 빠른 곳으로 움직이게 된다.

좀 더 구체적으로는, 말이 움직이기 시작할 때 우상단에 있던 경우에는, 윷길이 3번 윷길로 바뀐다. 
예를 들면, 우상단에서 한 칸 전진하면 앞모도, 두 칸 전진하면 앞모개의 위치에 있게 된다. 
윷의 위치에서 한 칸 전진하는 것을 두 번 진행하면 앞모도의 위치에 있지만,
두 칸 전진하는 것을 한 번 진행하면 뒷도의 위치에 있게 된다.

또, 말이 움직이기 시작할 때 좌상단에 있었던 경우에는 2번 윷길을 따르게 되어서, 
좌상단에서 한 칸 전진하면 뒷모도, 두 칸 전진하면 뒷모개의 위치에 있게 된다.

또한, 3번 윷길에 있던 말이 중앙에서 전진을 시작할 경우에는 1번 윷길을 따르게 된다. 
중앙에서 한 칸 전진하면 사려, 두 칸 전진하면 안찌의 위치에 있게 된다.

이렇게 윷길을 따라 이동한 말은 
우하단에 도착한 이후로 말이 한 칸 움직이면 판에서 빠져나가게 되어서 판에 다시 등장하지 않게 된다. 
전진을 두 번에 나눠서 하지 않고 한번에 해도 된다. 
예를 들면, 날걸에서 2칸을 전진하면 우하단에 도착하고, 한 칸 더 전진하면 빠져나가게 된다. 
날걸에서 3칸, 4칸, 5칸을 전진해도 빠져나갈 수 있다.

하지만 이렇게 되면 단지 윷가락을 잘 던져서 잘 빠져나가는 게임이 될 뿐이다. 
그래서 윷놀이에는 게임을 재밌게 하고 경쟁요소를 추가할 새로운 규칙들이 추가되었다.

하나는 말을 업는 규칙이다. 같은 위치에 있는 자기 편의 말이 두 개 이상 존재한다면, 
그 말 중 하나만 움직이는 것으로 전체 말을 다 움직이게 된다.

다른 하나는 말을 잡는 규칙이다. 
상대편의 말이 있는 위치가, 자신의 말의 목적지인 경우에는 
상대편의 말을 게임판에서 제거하여 시작하기 전의 위치로 옮긴다. 
이 말이 다시 출발하려면 우하단에서 부터 출발하게 된다.

당신은 이 윷놀이 게임의 개발을 맡게 되었다. 
당신이 해야할 일은 윷놀이의 각 턴이 주어졌을 때 판의 마지막 상태를 출력하는 일이다.

윷을 던지고 말을 움직인 횟수 n이 주어진다.
다음 n개의 줄의 i번째 줄에는 i번째 턴 정보가 주어진다.
턴 정보는 말에 대한 정보, 윷에 대한 정보가 주어진다.
말 구분은 ABCDabcd 중 하나로
각 윷에 대한 정보는 뒷면을 뜻하는 'B' 혹은 앞면 'F'가 공백으로 구분되지 않고 4개 이어서 주어진다.
말에 대한 정보와 윷에 대한 정보는 공백으로 구분된다.
대문자/소문자는 같은 팀 말이다.

기본적으로 윷판은 다음 32x32 문자열로 주어진다.
..----..----..----..----..----..
..    ..    ..    ..    ..    ..
| \                          / |
|  \                        /  |
|   \                      /   |
|    ..                  ..    |
..   ..                  ..   ..
..     \                /     ..
|       \              /       |
|        \            /        |
|         ..        ..         |
|         ..        ..         |
..          \      /          ..
..           \    /           ..
|             \  /             |
|              ..              |
|              ..              |
|             /  \             |
..           /    \           ..
..          /      \          ..
|         ..        ..         |
|         ..        ..         |
|        /            \        |
|       /              \       |
..     /                \     ..
..   ..                  ..   ..
|    ..                  ..    |
|   /                      \   |
|  /                        \  |
| /                          \ |
..    ..    ..    ..    ..    ..
..----..----..----..----..----..
"/\.|-", 공백, 개행문자로만 이루어져 있다.
각 칸은 2 × 2 모양의 '.' 문자로 표현이 되어 있다. 
가장 왼쪽 위 부터 행우선으로 칸을 읽으면, 
차례로 
좌상단, 뒷윷, 뒷걸, 뒷개, 뒷도, 우상단, 
뒷모도, 앞모도, 
찌도, 윷, 
뒷모개, 앞모개, 
찌개, 걸, 
중앙, 
찌걸, 개, 
속윷, 사려, 
찌윷, 도, 
속모, 안찌, 
좌하단, 날도, 날개, 날걸, 날윷 그리고 우하단 순이 된다.

여기서, N개의 턴이 진행된 후, 각 말이 어느 칸에 있는 지를 출력하여야 한다. 
각 칸에 있는 2 × 2 모양의 '.' 문자로 표현이 된 칸 중 한 칸에 출력한다.

A 혹은 a의 말은 왼쪽 위에, B 혹은 b의 말은 오른쪽 위에, 
C 혹은 c의 말은 왼쪽 아래에, D 혹은 d의 말은 오른쪽 아래에 
위치한 '.' 문자를 대체하여 출력한다.

1 <= N <= 100
모든 움직임은 올바르다.
"""

pos = {s: [-1, -1] for s in 'ABCDabcd'}

ty = ['r', 'u', 'l', 'd', '/', '\\']
node = {}
l_ed = {}
for t in ty:
    node[t] = {i: [] for i in range(6)}
    l_ed[t] = 5
# /, \는 7칸이니 추가/수정 해준다.
node['/'][6] = []
node['\\'][6] = []
l_ed['/'] = l_ed['\\'] = 6

over = {
    'r': 'u',
    'u': 'l',
    'l': 'd',
    '/': 'd',
}

curve = {
    'r': ('/', 0),
    'u': ('\\', 0),
    'l': ('d', 0),
    '/': ('d', 0),
    '\\': ('d', 5),
}

def del_p(pieces, l, n):
    for p in pieces:
        pos[p] = [-1, -1]
        node[l][n].remove(p)

def move(p, cnt):
    l, n = pos[p]
    if l == -1:  # 이제 보드 올라왔으면 r, 0으로 취급
        l, n = 'r', 0
        node['r'][0] = [p]
    pieces = node[l][n][:]  # 피스 업기. 적은 있을 수 없음
    if l == 'd' and n + cnt > 5:
        # 보드 탈출
        del_p(pieces, l, n)
        return
    nl, nc = l, n + cnt
    if nc > l_ed[nl]:  # 라인 넘어가면
        if nl == '\\':  # 보드 탈출
            # 처음부터 d이면서 넘은건 이미 처리함
            # d로 바뀐 경우는 5칸 미만으로 움직이므로 보드 탈출 불가
            del_p(pieces, nl, n)
            return
        nl = over[nl]
        nc -= l_ed[l]
    elif nc == l_ed[nl] and nl != 'd':  # 끝점 커브
        nl, nc = curve[nl]
    elif (nl, nc) == ('/', 3):  # 중앙 커브
        # 라인 초과로 / 올 일이 없어서 elif 가능
        nl = '\\'
    nxt = node[nl][nc]
    if nxt:  # 다른 피스가 있으면 먹기
        team = pieces[0].isupper()
        to_del = [x for x in nxt if x.isupper() != team]
        del_p(to_del, nl, nc)
    for p in pieces:  # 피스 이동
        pos[p] = [nl, nc]
        nxt.append(p)
        node[l][n].remove(p)

def set_p():
    board = [
        "..----..----..----..----..----..",
        "..    ..    ..    ..    ..    ..",
        "| \                          / |",
        "|  \                        /  |",
        "|   \                      /   |",
        "|    ..                  ..    |",
        "..   ..                  ..   ..",
        "..     \                /     ..",
        "|       \              /       |",
        "|        \            /        |",
        "|         ..        ..         |",
        "|         ..        ..         |",
        "..          \      /          ..",
        "..           \    /           ..",
        "|             \  /             |",
        "|              ..              |",
        "|              ..              |",
        "|             /  \             |",
        "..           /    \           ..",
        "..          /      \          ..",
        "|         ..        ..         |",
        "|         ..        ..         |",
        "|        /            \        |",
        "|       /              \       |",
        "..     /                \     ..",
        "..   ..                  ..   ..",
        "|    ..                  ..    |",
        "|   /                      \   |",
        "|  /                        \  |",
        "| /                          \ |",
        "..    ..    ..    ..    ..    ..",
        "..----..----..----..----..----..",
    ]
    mat = [list(r) for r in board]
    p2mat = {
        'r': {i: (30-i*6, 30) for i in range(6)},
        'u': {i: (0, 30-i*6) for i in range(6)},
        'l': {i: (i*6, 0) for i in range(6)},
        'd': {i: (30, i*6) for i in range(6)},
        '\\': {i: (i*5, i*5) for i in range(7)},
        '/': {i: (i*5, 30-i*5) for i in range(7)}
    }
    for p in pos:
        if pos[p] == [-1, -1]:  # 보드에 없는 피스
            continue
        l, n = pos[p]
        r, c = p2mat[l][n]
        p_t = p.lower()
        if p_t == 'a':
            mat[r][c] = p
        elif p_t == 'b':
            mat[r][c+1] = p
        elif p_t == 'c':
            mat[r+1][c] = p
        else:
            mat[r+1][c+1] = p
    return mat

for _ in range(int(input())):
    p, yut = input().split()
    move(p, yut.count('F') if 'F' in yut else 5)
for row in set_p():
    print(''.join(row))


"""
현 시점 플래 4. 제출 805. 정답률 22.204%
구현/시뮬 문제이나 시뮬 요소에 어려운 부분이 없고
구현할 것이 많아서 빡구현에 가까운 문제.

내 풀이가 파이썬 풀이 중 가장 빠르다.
숏코딩은 파이썬 6위인데
나보다 짧고 공개된 다른 코드들은 
하드코딩 경향이 심하거나 시간이 오래걸린다.

내 풀이는 규칙을 그대로 진행하고 마지막에 보드만 업데이트 해주는거라
가장 직관적인 풀이라 생각한다.
"""