# https://www.acmicpc.net/problem/6064
import sys
sys.stdin = open("input.txt")
def input():
    return sys.stdin.readline().rstrip()
"""
카잉 제국은 M과 N보다 작거나 같은 두 자연수 x, y로 각 년도를 <x:y>와 같은 형식으로 표현함.
첫 해를 <1:1>, 두번째 해를 <2:2>로 표현. 
<x:y>의 다음 해를 표현 한 것을 <x':y'>라고 하자.
만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다.
y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다.
<M:N>은 달력의 마지막 해다.
M, N, x, y가 주어질 때, <x:y>는 몇 번째 해인지 구하라.
1 <= M, N <= 4_0000
1 <= x <= M, 1 <= y <= N
<x:y>로 표현되는 해가 없다면 -1을 출력하라.
"""
def sol(m, n, x, y):
    if m < n:
        m, n = n, m
        x, y = y, x
    for i in range(x, m*n+1, m):
        if (i - y) % n == 0:
            return i
    return -1


for _ in range(int(input())):
    m, n, x, y = map(int, input().split())
    print(sol(m, n, x, y))


"""
현 시점 실버 1. 제출 67536. 정답률 26.521 %
브루트포스 태그를 달고있으면서 브루트포스로 풀면 시간초과가 발생한다.
<a:b>라고 하면 a와 b자리는 각각 1~m, 1~n까지의 숫자가 반복된다.
x는 m보다 작고, m 이전에는 i가 곧 a이므로 i를 x로 두고 시작한다.
그 부분부터 i를 m씩 증가시키면 a는 항상 x가 된다.
그 각각에 대해 b가 y인지 확인하면 된다.

y의 경우 처음에는 i%n == y를 사용했는데,
그렇게 하면 b가 n이 될 경우 i%n == 0이 되어 확인되지 않는다.
해결을 위해 (i-y)%n == 0을 사용했는데, 이는 i-y가 n의 배수이므로 b가 n인 곳이고
거기에서 i가 y만큼 증가하면 b가 y가 된다.
파이썬에서 분모가 음수라도 나머지연산의 값은 똑같이 반복되므로 문제가 없다.

m, n을 비교해서 바꿔준 이유는 m이 1이면 브루트포스와 같기 때문이다.
무슨 말이냐 하면, m과 n중 큰 수를 단위로 순회하여야 답을 빨리 찾는다는 것이다.

이 방법을 중국인의 나머지 정리라고 부른다고 하던데
실버1이라고 하기엔 지나치게 어렵다 느껴진다.
중국인의 나머지 정리 같은 특수 지식을 알지 못하면 풀이시간이 꽤 걸릴 것이다.

다른 풀이들을 보니 유클리드 알고리즘을 확장하여 사용했는데
수학을 그만큼 아는 사람도 활용할 사람도 사실상 없기 때문에 대부분은 블로그 풀이 복붙이다.
"""
