# https://www.acmicpc.net/problem/15686
import sys

sys.stdin = open("input.txt")


def input():
    return sys.stdin.readline().rstrip()


"""
nxn 도시. 0은 빈칸, 1은 집, 2는 치킨집. r, c는 1부터 시작.
치킨 거리는 집과 가장 가까운 치킨집 사이의 거리.
치킨 거리는 |r1-r2| + |c1-c2|로 구한다.
도시에 있는 치킨집 중 최대 M개를 남기고 나머지는 폐업시킨다.
도시의 치킨 거리의 최소값을 구하라.
2 <= n <= 50, 1 <= M <= 13
집은 적어도 1개 존재한다.
치킨집 개수는 M보다 크거나 같고 13보다 작거나 같다.
"""
from itertools import combinations

n, m = map(int, input().split())
mat = [list(map(int, input().split())) for _ in range(n)]
h2c_d = {}
c2pos = {}
cur = 0
for r in range(n):
    for c in range(n):
        if mat[r][c] == 1:
            h2c_d[(r, c)] = {}
        elif mat[r][c] == 2:
            c2pos[cur] = (r, c)
            cur += 1

def dist(pos1, pos2):
    r1, c1 = pos1
    r2, c2 = pos2
    return abs(r1 - r2) + abs(c1 - c2)

# 모든 집과 모든 치킨집 사이의 거리를 미리 계산해둠.
for h in h2c_d:
    for c_pos in c2pos:
        h2c_d[h][c_pos] = dist(h, c2pos[c_pos])

min_d = float("inf")
# m개를 고르는 모든 경우의 수에 대해
for c_cases in combinations(c2pos, m):
    case_d = 0
    # 각각의 집에 대해 치킨거리 계산
    for h in h2c_d:
        case_d += min(h2c_d[h][c] for c in c_cases)
    # 최소치킨거리 갱신
    min_d = min(min_d, case_d)
print(min_d)


"""
현 시점 골드 5. 제출 82883. 정답률 46.036 %
풀고 나서 다른 풀이들을 봤는데
내가 살펴본 모든 풀이가 m개를 남기는 케이스만 계산한다.

문제에서 분명 '최대 m개'를 남겨야 한다고 언급했으므로 
x개를 고른다고 하면 0<=x<=m을 모두 고려해야 한다.
0개를 고르는 것이 이상하게 느껴질 수 있지만 문제에서 치킨집을 최소 1개 남겨야 한다는 조건이 없다.
관대하게 봐서 '각각의 집이 치킨 거리를 갖고 있다 -> 치킨집 좌표가 존재한다'라고 해석해서 
최소 1개가 남는다고 쳐도 1~m개를 모두 고려해야 한다.

혹시나 m개를 고르는 것이 최적해라는 것을 증명한 사람이 있을까 했는데 나는 못찾았다. 
언급조차 없는걸 보면 다 그냥 복붙이다.
문제는 '어떻게 고르면' 최적해가 나오는지를 증명해야 하는데,
사람들은 그냥 'm개를 고르면 최적해가 나온다'를 암묵적 전제로 사용하여 문제를 풀고있다.

물론 나는 1~m을 다 고려하면 좀 느려서 m개를 골라야 한다는 점을 증명하고 m개만 사용했다.

0개를 고를 경우 치킨거리 자체가 존재하지 않으므로 제외한다. 1~m개 검토.
치킨집이 추가될 때 기존 치킨집과 좌표가 다를 것이므로 항상 좌표의 변동이 생긴다.
추가된 치킨집에 대해
1. 모든 집에 대해 기존 칰보다 멀 때
   1. 치킨거리 변화없음
2. 모든 집에 대해 기존 칰보다 가까울 때
   1. 치킨거리 줄어듦
3. 일부 집에 대해 가까워지고 일부 집에 대해 멀어질 때
   1. 치킨거리가 줄어듦

즉, 치킨집이 추가될 경우, 치킨거리가 길어지는 경우는 없다. 
문제는 도시의 치킨 거리가 가장 작은 케이스를 찾는 것이다. 
치킨집이 1개만 있어도 최소거리인 케이스에서도,
m개를 설치하고 검토한 치킨거리와 같게 나온다는 것.

그러므로 1~m개를 모두 검토할 필요가 없이 m개를 고른 케이스만 검토하면 된다.

또한, 조합을 사용한 사람들은 각 케이스에 대해 집과 치킨집의 거리를 매번 계산하는데, 
이는 굉장히 비효율적이다.
그래서 나는 처음에 모든 집과 치킨집 사이의 거리를 계산해뒀다.
실제 제출에서는 내 풀이가 느린 것을 보니 딕셔너리 저장과 접근, 
언패킹 등에서 예상보다 시간이 잡아먹히는 듯 하긴 한데, 
구조상으로는 미리 계산해두는게 맞는 듯 하다.

dfs를 사용하는 경우는 백트래킹 과정에서 이전 계산결과를 이용할 수 있어서 
내 풀이보다 더 빠른 듯 하다.
"""
