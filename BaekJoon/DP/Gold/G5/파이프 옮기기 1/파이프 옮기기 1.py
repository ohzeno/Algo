# https://www.acmicpc.net/problem/17070
import sys
sys.stdin = open('input.txt')
def input():
    return sys.stdin.readline().rstrip()
"""
nxn 격자. 1,1부터 시작. 0은 빈 칸, 1은 벽.
파이프는 2칸 연결. 대각선 아래도 연결 가능. 대각선 위는 불가.
파이프는 벽을 지날 수 없음. 
파이프를 오른쪽, 아래, 오른쪽 아래 대각선으로 밀 수 있음.
한 번 밀 때 45도까지 회전 가능.
미는 움직임은 자동차같음. 방향 바꾸더라도 전진하며 바꿈.
처음에 (1, 1)과 (1, 2)에 파이프가 놓여있음.
파이프 한쪽 끝을 n, n으로 이동시키는 방법의 수를 구하라.
3 <= n <= 16
이동시킬 수 없으면 0을 출력.
방법 수는 항상 1,000,000보다 작거나 같다.
"""
n = int(input())
mat = [[0] * (n+1)]
mat += [[0] + list(map(int, input().split())) for _ in range(n)]
dp = [[[0, 0, 0] for _ in range(n+1)] for _ in range(n+1)]
# dp[r][c] = [가로, 세로, 대각선] 누적 경로 수
dp[1][2][0] = 1  # 왼쪽 꼬리는 필요 없음
for r in range(1, n+1):
    for c in range(1, n+1):
        if mat[r][c] == 1:  # 벽이면 무시
            continue
        # 가로: 왼쪽 가로에서 오거나 왼쪽 대각선에서 오거나
        dp[r][c][0] += dp[r][c-1][0] + dp[r][c-1][2]
        # 세로: 위쪽 세로에서 오거나 위쪽 대각선에서 오거나
        dp[r][c][1] += dp[r-1][c][1] + dp[r-1][c][2]
        if mat[r-1][c] == mat[r][c-1] == 0:  # 대각선: 위쪽, 왼쪽이 빈칸이어야 함
            dp[r][c][2] += sum(dp[r-1][c-1])  # 모든 케이스에서 대각선으로 올 수 있음
print(sum(dp[n][n]))


"""
현 시점 골드 5. 제출 38213. 정답률 45.924 %
처음에 bfs로 풀려고 했는데, 시작 지점과 도착 지점 사이의 특정 지점에서
방문처리를 해서 중복 방문을 방지하면 경우의 수를 깎아먹게 되고,
방문처리를 하지 않으면 같은 경로에 대한 엄청나게 많은 중복 계산이 발생한다.
그런 면에서 dp 풀이는 딱히 중복 계산이 일어나지 않는다.
dp구조를 어떻게 잡을까 좀 시간을 썼는데, 
그냥 가로, 세로, 대각선 누적 경로 수를 각 지점에 저장했다. 
"""