# https://www.acmicpc.net/problem/22871
import sys
sys.stdin = open('input.txt')
def input():
    return sys.stdin.readline().rstrip()

"""
n개 돌이 일렬로 나열. 1~n번. 1에서 출발하여 n으로 이동
1. 항상 오른쪽으로만 이동 가능
2. i번 돌에서 j번 돌로 이동할 때 (j-i) * (1 + |Ai - Aj|)만큼 힘을 쓴다.
3. 돌을 한 번 건너갈 때마다 쓸 수 있는 힘은 최대 K.
K의 최소값?
"""

n = int(input())
datas = list(map(int, input().split()))

def solve(n, a):
    """
    이상하게 solve함수를 만들지 않고 같은 로직으로 진행하면 시간초과가 발생한다.
    dp[i]는 i까지 이동할 때 최대 k 중 최소값이다.
    d[0]이 0인 이유는 0에서 0으로 이동할 때 힘을 쓰지 않기 때문이다.
    나머지가 inf인 이유는 0에서 i로 이동할 때 최대 k를 모르기 때문이다.
    임의의 값과 min연산을 해야하기에 inf를 넣어놓았다.
    """
    dp = [0] + [float('inf')] * (n - 1)
    """
    각 ed에 도달하는 모든 경우의 수 검토. 
    ed를 1부터 업데이트해야 -1에 도달했을 때 모든 경우의 수가 고려된다.
    앞쪽 돌에 도달하는 최소 max_k를 알아야 뒤쪽 돌에서 최적해를 구할 수 있다. 
    그게 dp고.
    """
    for ed in range(1, n):
        for st in range(ed):
            direct = (ed - st) * (1 + abs(a[ed] - a[st]))  # st에서 ed로 곧장 이동할 때 힘
            # dp[st]가 direct보다 크다면 st를 거쳐 ed로 올 때 최대 k는 dp[st]가 된다.
            max_k = max(dp[st], direct)
            """
            최대 k 중 최소값. 기존 dp[ed]보다 작다면 해당 값이 최소값이 된다.
            dp[-1]에서 최소 max_k를 계산하는게 목표지만, 
            결국 중간 과정에서 min을 넘어서는 max_k는 걸러지게 될 것이므로 고려할 필요가 없다.
            즉, 중간 과정에서부터 최소값을 찾아나가면 마지막에 dp[-1]이 최소값이 된다.
            """
            dp[ed] = min(dp[ed], max_k)
    return dp[-1]

print(solve(n, datas))

"""
현 시점 실버 1. 제출 950. 정답률 31.761 %
문제 설명이 난해하다. 한 번의 이동에서 최대K를 쓸 수 있다고 하는데,
0에서 n-1까지 이동하는 모든 경우 중 k의 최소값을 구하라고 한다.

이 두 문장을 조합하면 0에서 n-1까지 이동하는 모든 경우 중 
'한 번의 이동'에서 사용하는 힘 중 최소값을 구하는게 된다.
예를 들어 코스에서 2, 3, 6을 사용했다면 2를 선택하면 된다.
'최대 K'라는 말이 각 이동에 한정되고, k가 주어지지 않았으므로 '최대'라는 말은 의미가 없다.

'한 번의 이동에서 최대 K를 쓴다'가 아니라 '한 번의 이동에서 쓰는 힘의 최대값은 K다'라고
억지로 끼워맞춰도 임의의 i에서 임의의 j로 이동하는 비용 중 최대값을 구하는게 된다.
그렇게 보면 'k의 최소값을 구해라'라는 말과 충돌한다.

한 번의 결제에 최대 x원을 쓸 수 있다. x의 최소값을 구해라. 하지만 x는 주어지지 않았다. 
이러면 x는 내가 정하는거라 '최소값'이 의미가 없다.

문제 설명이 논리적으로 문제가 있다는 것이다.

한참 헤매다 결국 정답풀이들을 보고 문제의 의도를 도출했다. 
문제에서 의도한 바는, 0에서 n-1까지 이동하는 모든 코스를 살펴보며
각 코스마다, 코스 내에서 발생한 각각의 이동에서 사용한 힘 중 최대값을 구하고,
그 코스별 최대값을 모아서 최소값을 구하는 것이다.

정답풀이를 올려놓은 사람들은 어느 방법을 사용하더라도 
python3로는 통과가 불가능하고, pypy3로만 통과가 가능하다고 적어놓았으나
나는 python3로 통과했고, 
채점 페이지를 살펴보면 나를 제외하고도 python3로 통과한 사람이 5명 있다.

시간 제한 기준이 굉장히 불가사의한데, 본문의 풀이를 함수로 작성하지 않으면 시간초과가 발생한다.
함수 호출과 리턴과정에서 시간을 더 잡아먹을 것 같은데 오히려 그것만 통과하니 이상하다.
약간의 시간차이인가 싶어 여러번 제출해봤으나 결과는 같았다.
맞힌 사람 중 python3로 푼 사람이 한 사람 더 있는데, 
내 로직에서 안쪽 for루프에서 배열에 값을 추가하고
안쪽 루프가 끝나면 min을 해주는 연산을 했다.
내 로직은 안쪽 for루프에서 min연산을 매번 해주지만, 
그 사람은 append를 매번 하고, min은 루프 바깥에서 한 번만 했는데, 그 차이가 아닐까 싶다.
그 사람의 풀이는 함수를 사용하지 않았다.

본래 이분탐색을 위해 찾은 문제인데, 일단 dp가 더 편해보여 dp로 풀었다.
실버1이지만 상당히 힘들었다. 
문제 설명에 논리적 오류가 있어 언어적으로 올바르게 해석하면 오히려 문제를 풀 수 없다.
한참 헤매다가 다른 정답풀이들을 보고 문제의 의도를 도출해냈고,
의도를 알더라도 dp를 어떻게 사용해야 할 지 찾아내기 힘들었다. 골드 문제들보다 더.
처음엔 2차원 dp로 풀려고 시도하며 한참 헤맸다.

나중에 이분탐색으로도 풀어볼 생각이다.
"""
