# https://www.acmicpc.net/problem/18870
import sys
sys.stdin = open('input.txt')
def input():
    return sys.stdin.readline().rstrip()

"""
수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.
Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.
X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.
"""

n = int(input())
datas = list(map(int, input().split()))
cnt_d = dict(zip(sorted(set(datas)), range(n)))  # zip은 짧은 이터러블을 기준으로 묶는다.
print(*[cnt_d[data] for data in datas])

"""
현 시점 실버2. 제출 60869, 정답률 39.597%
문제 이해가 안돼서 질문 게시판을 참고했다.

Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.
이 말은 주어진 N개의 좌표 중 
Xi보다 값이 작은 좌표를 중복 없이 세었을 때의 개수가 X'i의 값이 된다는 뜻이다.

원문은 언어적으로나 논리적으로나 굉장히 문제가 많다. 
문장 필수성분이나 단어, 변수 정의 좀 빼먹지 않으면 좋겠다.
주어진 N개의 좌표 중 Xi> Xj를 만족하는 임의의 j 중에서, Xj값이 중복되지 않는 j의 갯수를 X'i로 정의한다.
라고 해야 한다.

cnt_d에 대해 좀 설명하면, 결국 X'i는 자신보다 작은 좌표를 중복없이 세어야 하기에, 
sorted(set(datas))를 통해 중복을 제거하고 정렬한다. 
range(n)과 길이가 맞지 않지만 zip은 그런 경우 짧은 쪽 기준으로 잘라내서 조합한다. 
cnt_d의 키는 정렬되어 있기에 값은 range(n)을 사용했기에 0부터 시작한다. 
그러니 자신보다 작은 중복 없는 좌표의 갯수가 된다.
하지만 xi의 i의 순서대로 출력해야 하기에, 딕셔너리로 저장해놓고, datas를 순회하며 값을 출력한 것이다.

백준의 분류로는 정렬, 값/좌표 압축이지만, 
정렬을 주로 하는 문제가 아니고, 
값/좌표 압축은 알고리즘이라고 하기엔 임의의 규칙으로 만들어진 방법이라 일단 그리디 폴더에 넣는다.
"""
