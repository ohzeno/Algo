# https://school.programmers.co.kr/learn/courses/30/lessons/12987
"""
N명씩 두 팀으로 나눔.
먼저 모든 사원이 무작위 자연수 하나씩 부여받음.
각 사원은 딱 한 번씩 경기함.
각 경기당 A/B팀에서 각 1명씩 나와서 수를 비교함.
수가 큰 쪽의 팀은 1점을 얻음.
A팀의 출전 순서가 주어졌을 때 B팀이 얻을 수 있는 최대 점수를 구해라.
1 <= 팀 길이 <= 10^5
1 <= A[i] <= 10^9
"""
def solution(A, B):
    A.sort()
    B.sort()  # 최대한 작은 수로 이겨야 이기는 횟수가 많아짐.
    cnt = 0
    ai = 0  # A에서 이길 수 있는 최대한 작은 수의 인덱스
    for b in B:
        if b > A[ai]:
            cnt += 1
            ai += 1  # 이겼으니 A 포인터 이동
    return cnt

inputdatas = [
    [[5,1,3,7], [2,2,6,8]],
    [[2,2,2,2], [1,1,1,1]],
]

"""
Summer/Winter Coding(~2018) 기출. 
Lv.3. 현 시점 완료한 사람 6,531명, 정답률 54%
명확한 방법이 생각나지 않아 10분 걸렸다.
A를 작은순으로 정렬하여 A의 각 작은 수를 이길 수 있는 최대한 작은 B의 원소를 찾아야 한다.
직관적인 방법이었고, 그대로 구현해서 풀었다.

다른 좋은 방법이 있을거라 생각했는데 다른 사람들 풀이도 내 로직과 일치하거나 비슷했다.
"""

for t in inputdatas:
    print(solution(*t))
