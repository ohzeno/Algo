# https://school.programmers.co.kr/learn/courses/30/lessons/12982
"""
부서가 신청한 금액을 정확히 지원해야 함.
최대 몇 개의 부서에 지원할 수 있는지 return
"""
def solution(d, budget):
    d.sort()
    cnt = 0
    for i in d:
        if budget < i:
            break
        budget -= i
        cnt += 1
    return cnt


inputdatas = [
    [[1,3,2,5,4], 9],
    [[2,2,3,3], 10],
]

"""
Summer/Winter Coding(~2018) 기출. 
Lv.1. 현 시점 완료한 사람 35,285명, 정답률 74%
수학적 증명이 되는 방법을 찾으려 해서 
combinations로 모든 케이스를 순회했더니 시간초과가 발생했다.

정답률이 74%인 이유는 휴리스틱이 더 쉽기 때문이다.
작은 예산을 많이 넣으면 최적일거라는 직관적인 생각대로 풀면 맞다.
증명하고 풀어야 한다고 하면 74%중 대부분이 틀렸을 것이다.

귀류법 이용한 증명.
정렬 후 작은 순으로 할당하는 방법을 A
A가 아닌 최적 방법 B가 존자한다고 가정하자
정렬순으로 살펴보면서
A가 n개를 선택한다면, B는 n개 초과로 분배가 가능해야 한다.
A가 1, 2, 3번에 할당했다면
B는 정렬순이 아니므로 1, 2, 3중 하나는 비었다고 가정한다
(결과가 겹쳐서 1,2,3 선택이면 A보다 더 많이 고를 수 없다. 여기선 1이 비었다고 가정)
(방법의 결과가 겹쳐서 1, 2, 3에 할당했다면, A와 같은 방법이므로 더 할당할 수 없다.)
B가 더 많이 할당해야 하므로 최소 2개를 더 할당해야 한다
(여기선 4, 5. 그나마 신청 예산 작은 부서들이니)
Cn을 n번 부서의 예산이라고 하고 total은 전체 예산이라고 하자.

A에서 
total - C1 - C2 - C3 < C4
total - C2 - C3 < C4 + C1
B의 상황은 
total - C2 - C3 - C4 - C5 >= 0
total - C2 - C3 >= C4 + C5
연립하면
C4 + C5 <= total - C2 - C3 < C4 + C1

즉 C5 < C1이다.
하지만 작은 순 정렬이므로 C1 <= C5이다.
모순 발생. 따라서 A 외에 최적방법이 존재한다는 가정이 틀렸다.
1~3 중 최소 하나가 비는 것이니, 뭘 비웠든 C5와의 비교이므로 결과는 같다.
"""

for t in inputdatas:
    print(solution(*t))
