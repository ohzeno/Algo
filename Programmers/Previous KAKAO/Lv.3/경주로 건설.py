# https://school.programmers.co.kr/learn/courses/30/lessons/67259
def solution(board):
    # 0, 0(좌상단)에서 시작, 도착은 (n-1, n-1)(우하단)
    # 상하/좌우 이어진 2칸은 직선도로 1개.
    # 직선도로 2개 직각으로 만나는 부분은 코너.
    # 직선도로 100원 코너 500원
    # 최소비용?
    n = len(board)
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 우 하 좌 상
    # 500 * n ** 2는 모든 칸에 코너가 설치되는 경우의 비용. 이론적으로 불가능함.
    visited = [[500 * n ** 2] * n for _ in range(n)]  # 방문처리, dp용으로 사용
    visited[0][0] = 0  # 시작점 비용은 0으로
    def dfs(r, c, cnt_dir, cost):
        if r == n-1 == c:  # 도착했으면 종료
            return
        for i in range(4):  # 네 방향 체크
            nr, nc = r + dirs[i][0], c + dirs[i][1]  # 네 방향 다음 좌표
            # 다음 좌표가 맵 안이고 벽이 아니면
            if 0 <= nr < n and 0 <= nc < n and board[nr][nc] == 0:
                if r == 0 == c:  # 현 좌표가 0, 0이면 방향 고려X
                    tmp_cost = 100
                elif cnt_dir != i:  # 방향 꺾으면 코너, 직선도로 비용 추가
                    tmp_cost = cost + 600
                else:  # 직진이면 직선도로 비용만 추가
                    tmp_cost = cost + 100
                if tmp_cost <= visited[nr][nc]:  # 새 비용이 이전 비용보다 작으면 갱신 후 dfs
                    visited[nr][nc] = tmp_cost
                    dfs(nr, nc, i, tmp_cost)
    dfs(0, 0, 0, 0)
    return visited[n-1][n-1]  # 도착점 최소비용 리턴

inputdatas = [
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 1],
        [0, 0, 1, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 1, 0, 0],
        [1, 0, 0, 0, 0, 0, 0, 0],
    ],
    [
        [0, 0, 1, 0],
        [0, 0, 0, 0],
        [0, 1, 0, 1],
        [1, 0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 0],
        [0, 0, 1, 0, 0, 0],
        [1, 0, 0, 1, 0, 1],
        [0, 1, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 0],
    ],
]

"""
2020 카카오 인턴십 기출. Lv.3. 총 35분 소모.
옮겨적고 문제 읽는데만 9분을 사용했다. 
21분 후 dfs를 이용한 초안을 만들었으나 몇 테케에서 시간초과가 발생하여 72점을 받았다.
시간을 줄일 방법이 생각 안나 질문탭을 훑었고, DP를 사용해보라는 말들을 봤다.
dp를 적용할 방법이 생각나지 않아 질문탭을 본 것이라, 한동안 방법이 생각나지 않았다.
잠시 후 현 위치까지의 비용의 최소값을 기록하는 방법이 생각났고
2분동안 추가로 DP를 구현하여 제출, 통과했다.
이 문제는 각 경로가 겹칠 수 있기에 나는 bfs를 사용하지 않았다.
하지만 베스트 풀이를 보니 visited에 코스트를 기록, 
방문한 곳이라면 코스트가 더 작은 경우에만 체크하는 방식으로 bfs를 사용했다.
해당 풀이를 보고 내 풀이의 dfs도 visited를 경로마다 독립시키지 않고 
dp 기록으로 사용하도록 고쳤더니 성능이 개선됐다.
"""
for t in inputdatas:
    print(solution(t))
