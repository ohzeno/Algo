# https://school.programmers.co.kr/learn/courses/30/lessons/67260
from collections import deque
import sys
sys.setrecursionlimit(3*10**5)
def solution(n, path, order):
    # 0~n-1 방번호. 동굴 입구는 0번과 연결돼있음.
    # 각 방들은 양방향 연결됨. 서로 다른 방 연결하는 통로는 하나.
    # 임의 두 방 사이 최단경로는 한 가지만 있음.
    # 임의 두 방 사이 이동 불가한 경우 없음
    # 1. 모든 방 적어도 한 번 방문
    # 2. 특정 방은 방문 전 반드시 먼저 방문해야 하는 방이 정해져있음.
    #   2-1. 사전 방문 방은 0~1개
    #   2-2. 서로 다른 두 개 이상 방에 대해 사전 방문 방이 같은 경우 없음
    #   2-3. 어떤 방이 사전 방문 방이면서 나중에 방문해야 하는 경우는 없음
    # 방문계획
    # - ab, ac 처럼 a 이후 방문해야 할 방이 두 개 이상인 경우X
    # - xa, za 처럼 a 사전 방문 방이 둘 이상인 경우 X
    # - ab bc 처럼 a 방문 후, c 방문 전이 중첩되는 경우 X
    # ab면 acb도 가능. 꼭 연속해서 바로 방문해야 하지는 않음.
    # n: 방 개수. 2~20만,
    # path: 연결. 길이 n-1.
    # order: 프로도가 정한 방문 순서. 길이 1~n/2
    # 규칙에 맞게 모든 방을 탐험할 수 있는지 return
    connect = {i: [] for i in range(n)}  # 연결노드 전부 기록
    sts = {}  # 선순위: 후순위
    eds = {}  # 후순위: 선순위
    for st, ed in path:
        connect[st].append(ed)
        connect[ed].append(st)
    for a, b in order:
        if b == 0:  # 0이 출발점인데 후순위면 답이 없다.
            return False
        eds[b] = a
        sts[a] = b
    def dfs(cur):
        checked[cur] = 1  # 확인처리
        if cur in eds:  # 조건 만족 못한 후순위면 리턴
            return
        if cur in sts:  # 선순위면
            nxt = sts[cur]
            eds.pop(nxt)  # 순서 조건 만족했으니 대응하는 후순위 제거.
            if checked[nxt]:  # 후순위에 이미 방문했었으면 이제 탐색
                for node in connect[nxt]:
                    if not checked[node]:
                        dfs(node)
        for node in connect[cur]:  # 현재 노드 자식노드들 탐색
            if not checked[node]:
                dfs(node)
    checked = [0] * n  # 후순위를 처리해두고 나중에 탐색하기에 방문 순서와는 다르다.
    dfs(0)
    return not eds  # 후순위가 남아있지 않으면 전부 조건 만족해서 True, 남아있으면 False


inputdatas = [
    [
        9,
        [[0, 1], [0, 3], [0, 7], [8, 1], [3, 6], [1, 2], [4, 7], [7, 5]],
        [[8, 5], [6, 7], [4, 1]]
    ],
    [
        9,
        [[8, 1], [0, 1], [1, 2], [0, 7], [4, 7], [0, 3], [7, 5], [3, 6]],
        [[4, 1], [5, 2]]
    ],
    [
        9,
        [[0, 1], [0, 3], [0, 7], [8, 1], [3, 6], [1, 2], [4, 7], [7, 5]],
        [[4, 1], [8, 7], [6, 5]]
    ],
]

"""
2020 카카오 인턴십 기출. Lv.4. 현 시점 완료한 사람 1197, 정답률 18%
인풋데이터 옮겨적고 문제 읽고 규칙 옮겨적고 초기 아이디어 작성까지 16분 45초 걸림.
몇 시간동안 못풀어서 정답 풀이 작성까지 며칠 걸렸다. 
비정상적인 dfs라 실전에선 시간 안에 생각해내지 못했을듯.
다른 사람들은 대부분 카카오 해설대로 풀거나 해설을 bfs로 변형해서 풀었다.
풀이가 딱 2종류로 수렴하는 듯...
dfs라고 적어놓고 bfs 사용한 사람들도 있다.

간선의 개수가 n-1이며 두 방 사이에 이동이 불가능한 경우가 없으므로 모두 연결돼있다.
즉, 그래프는 트리형태다.
탐색 과정에서 순환이 발생하면 안되는데, 
그러려면 부모-자식관계가 명확해서 기록부터 단방향이 되거나 노드의 깊이를 알 수 있어야 한다.
하지만 0을 제외하면 부모를 알 수가 없다. 연결 후에 0부터 탐색하면서 단방향 그래프를 새로 만들어봤다.
현 노드보다 낮은 단계만 can_visite에 넣어 순회하도록 해보았다.
처음엔 Trie를 만들었다가 매번 노드를 탐색하며 시간낭비 되는 코드가 되었다.
굳이 트라이를 사용하며 고치기에는 복잡하다 느껴 딕셔너리를 사용했다.

89분 초안 제출. 효율성 2.9 정확성 23.5. 정확성에서도 시간초과가 다수 발생했으며 런타임에러가 매우 많았다.
로직은 정확하다 생각했지만 정확성 테케 30을 틀렸다.

visited를 사용하면 순환이 발생하지 않기에 tmp_connect만 남기고, 자식 순회하며 단방향 그래프 만드는 과정을 없앴다.
100분 해당 코드 제출. 점수는 같았고, 테케 30 실패, 정확성 테스트에서 런타임 에러, 시간초과 다수 발생하는 상황도 그대로였다.

101분 재귀 제한해제하고 제출.
런타임에러 사라짐. 정확성 30.9, 효율 2.9.

0이 입구임에도 order에서 0번 방 이전에 방문해야 할 방을 지정하는 경우가 있다.
dfs 과정에서 before[0]을 체크하는 경우가 없기에 정확성 테케30을 틀린 듯 하다.
107분 해당 코드 제출, 테케 30만 추가 통과.

처음에 단방향 그래프를 만들거나 양방향 그래프에서 visited를 사용하거나 결과는 같았다.
can_visit.copy()에서 copy만 제거하니 정확성 테케의 시간초과가 사라졌다.
copy를 사용한 이유는 순회 도중 깊은 재귀쪽에서 노드가 제거되면 위쪽에서 가능성체크를 못하는 것을 우려한 것이다.
하지만 단방향 그래프라 아래쪽에서 제거될 경우 이미 방문한 것이 되어 위쪽에서 체크할 이유가 없다.
또한 재귀 전에 방문해도 되는지 체크하기에 문제가 있으면 제거될 일이 없다.
can_visit 자체가 깊이와 무관하게 다음을 제시하고, count도 그에 따라 증가하기에
재귀에서 빠져나와서 다음으로 가는게 아니라 재귀 안에서 can_visit을 확인하고 
다음 재귀로 가며 count가 증가한다. 즉, 한번에 n만큼의 경로깊이가 만들어지므로 copy가 필요없다. 
can_visit 자체를 밖으로 빼줬다.
can_visit에서 remove 작업이 오래걸릴거라 생각해 set로 만들어봤으나 시간차이도 크지 않았고
copy를 없애니 순회 도중 구성물이 바뀌었다고 에러가 발생했다.

O(n)인 remove 자체를 없애고 현재 노드에 대한 visited 처리, 다음 노드에 대한 방문여부 체크를 했다.
remove에서 시간이 절약되지만 can_visit 순회가 O(n)으로 증가하기에 시간 절약 효과는 없다.
결과는 동일.

기존에는 can_visit을 사용해 방문 가능한 노드들을 만들어놓고 
조건에 맞는 부분만 순회하는 식으로 dfs를 진행했다. 
이렇게 한 이유는 한 노드를 탐색했더라도 조건에 따라 
상위 노드로 가서 다른 서브트리를 탐색한 후 다시 현 노드의 하위 노드들을 탐색해야 
하는 상황이기 때문이다. visited만을 이용하면 부모 노드로 돌아갈 수 없으므로 
같은 깊이의 다른 노드들을 탐색하러 갈 수도, 돌아올 수도 없다. 
그래서 방문 가능한 노드를 미리 기록해둬서 부모노드로 돌아가거나 
현 노드로 돌아오는 과정을 없애서 순환탐색을 없앤 것이다.
하지만 can_visit에 많은 노드가 들어가며 순회에 시간이 오래걸렸다.
그렇다고 이미 처리된 노드를 없애려 set를 사용하면 can_visit 순회 도중 원소가 제거되어 오류가 발생한다.
오류를 막기 위해 순회 과정에서 set를 copy하면 그건 그거대로 시간을 소모한다.

새 dfs에서는 sts딕셔너리에 후순위를 저장해둬서 상위노드로 이동하지 않고 
바로 후순위 노드의 서브트리를 탐색하도록 하여 순환탐색도 없고 can_visit도 없이 탐색이 가능해졌다.

이전 dfs에서는 connect[cur]를 순회한 후
can_visit을 순회하면서 connect[cur]를 두 번 순회한 꼴이 되었다.
또한, 다음 노드가 후순위며, 선순위를 탐색하지 않았을 경우 아예 dfs에 진입하지 않았다. 순회 막바지에는 can_visit이 상당히 커져 visited로 가지치기를 하더라도 시간을 많이 잡아먹었을 것이다.

새 dfs에서는 후순위여도 진입하여 방문처리한다. 현 노드가 후순위면 리턴한다. 현 노드가 선순위면 대응하는 후순위를 제거하고, 후순위에 이미 방문했었다면 후순위의 자식노드들을 탐색한다. 후순위를 미리 방문처리 하고, 나중에 선순위가 나왔을 때 탐색하는 특이한 방법이다. 정상적인 dfs는 아니다.
can_visit 순회가 따로 없기에 시간이 절약된다.

can_visit을 순회하는 과정이 제거됐다는 부분이 시간을 절약해준 것으로 추정한다. 큰 규모 트리데이터가 없어서 확인은 하지 못했다.
"""

for t in inputdatas:
    print(solution(t[0], t[1], t[2]))
