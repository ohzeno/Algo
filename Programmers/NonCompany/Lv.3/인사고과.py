# https://school.programmers.co.kr/learn/courses/30/lessons/152995
"""
어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 있다면
그 사원은 인센티브를 받지 못한다.
그렇지 않은 사원들을 두 점수의 합이 높은 순으로 석차를 내어
석차에 따라 인센티브가 차등 지급된다.
두 점수의 합이 동일하면 동석차. 동석차 수만큼 다음 석차는 건너뜀.
1 <= len(scores) <= 10^5
scores 각 원소
[근무 태도 점수, 동료 평가 점수]
scores[0]의 석차를 리턴.
인센티브를 받지 못하면 -1 return.
"""


def solution(scores):
    # 정렬 전에 완호 점수 기록
    t1, t2 = scores[0]
    tsum = t1 + t2
    # x 내림차순, y 오름차순
    scores.sort(key=lambda x: (-x[0], x[1]))
    max_p2 = 0  # y 최대값
    rank = 1
    for p1, p2 in scores:
        # 완호보다 두 점수 모두 높은 케이스가 있으면 -1
        if t1 < p1 and t2 < p2:
            return -1
        # y 최대값보다 작으면 x도 작은 케이스임. 인센티브 X
        if p2 < max_p2:
            continue
        """
        두 점수 합이 완호보다 크면 석차 +1
        완호의 등수는 앞에 동석차가 있든 없든 더 높은 점수 인원수 + 1이다.
        100 99 99나 100 100 100이나 완호가 90점이면 4등.
        """
        if tsum < p1 + p2:
            rank += 1
        # 위에서 걸러줘서 y 최대값보다 크거나 같은 케이스만 남으므로 y 최대값 갱신.
        max_p2 = p2
    return rank


inputdatas = [
    [[2, 2], [1, 4], [3, 2], [3, 2], [2, 1]],
]

"""
연습문제
Lv.3. 현 시점 완료한 사람 2,009명, 정답률 35%
이건 풀어본 적 없으면 정답 찾기가 상당히 힘들 듯 하다.
효율성 테스트도 없으면서 시간제한이 빡빡하다.
우선순위 큐 이용해서 20분 가량 헤맸으나 시간초과를 해결하지 못했다.

순회 한 번에 해결하는게 관건이다.
두 점수가 모두 다른 사람보다 작은 케이스를 찾는게 까다로운데
첫 점수 내림차순, 두번째 점수 오름차순으로 정렬하면 된다.
여기서 첫 점수를 x, 두번째 점수를 y라고 하고
각 순회에서 첫 점수를 xi, 두번째 점수를 yi라고 하자.
그러면 x가 같은 케이스 내에서는 두 점수가 모두 낮은 경우가 없다.
x1(내림차순이니 x1이 x최대값) 케이스를 순회하며 x1그룹의 y 최대값(이하 My)이 정해진다.
이후 x가 작아지면 적어도 첫 점수는 x1보다 작다.
이제 yi까지 My보다 작다면 인센티브를 받지 못한다.
yi는 오름차순으로 정렬되어 있으므로 My보다 작은 경우들은 continue로 건너뛰면 된다.
y값이 My보다 커지면 새로운 My가 된다.
y값을 오름차순으로 정렬한 이유가 이것인데,
오름차순이 아니라면
My가 10인 상태에서 (8,12), (8, 10)이 들어오면 
(8,10)은 My가 12가 된 후에 체크되므로 인센티브를 받지 못한다고 판정된다.

x는 내림차순, y는 오름차순이므로 
My가 갱신된 후에 My보다 y가 작은 케이스는 x값도 이전보다 작아서 제외할 수 있다.
ex) (9,9), (8,10), (8,11), (7,10)
8그룹 내에서 y값은 오름차순이므로 My보다 y가 작은 케이스는 7그룹 이하에서만 나올 수 있다.
그러니 인센티브 체크는 y값만으로 진행한다.
"""

for t in inputdatas:
    print(solution(t))
