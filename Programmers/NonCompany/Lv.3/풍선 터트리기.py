# https://school.programmers.co.kr/learn/courses/30/lessons/68646
"""
n개 풍선이 일렬로 나열되어 있다. 각각의 풍선에는 서로 다른 숫자가 쓰여있다.
아래 과정을 반복하며 풍선을 1개만 남기려 한다.
1. 임의의 인접한 두 풍선을 골라 하나를 터트림
    1-1. 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있음.
2. 터진 풍선으로 인해 빈 공간이 생기면 풍선들을 중앙으로 밀착시킴
최후까지 남기는 것이 가능한 풍선들의 개수를 리턴하라.
a의 길이는 1 이상 1,000,000 이하입니다.
    a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다.
    a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
    a의 모든 수는 서로 다릅니다.
"""


def solution(a):
    ans = {a[0], a[-1]}
    for arr in (a, a[::-1]):
        min_b = arr[0]
        for i, b in enumerate(arr):
            if b < min_b:
                ans.add(b)
                min_b = b
    return len(ans)


inputdatas = [
    {"data": [[9, -1, -5]], "answer": 3},
    {"data": [[-16, 27, 65, -2, 58, -92, -71, -68, -61, -33]], "answer": 6},
]

"""
월간 코드 챌린지 시즌1
Lv.3. 현 시점 완료한 사람 4163명, 정답률 40%
처음엔 시뮬레이션을 해야하나 했으나 a가 10^6이므로 시간복잡도가 너무 커질 것 같았다.
규칙을 통해 법칙을 도출해서 풀어야 한다.
1. 양끝은 무조건 남을 수 있다.
    예를들어 첫 원소를 남기고자 하면, 첫 원소를 포함해 두 원소가 남을 때까지
    오른쪽 원소들을 비교하며 큰 쪽을 터트린다.
    '작은 쪽을 터트리는 기회'가 남아있으므로 
    마지막 남은 원소를 터트려 첫 원소를 남길 수 있다. 
    반대편도 마찬가지.
2. 양끝을 제외한 원소들은, '작은 쪽을 터트리는 기회'를 이용해야 한다.
    왼쪽부터 순회한다면, 이전보다 작은 원소가 나온다면, 그 원소는 무조건 남길 수 있다.
    그 원소의 왼쪽은 '이전 최소값' 원소보다 큰 원소들을 터트려서, '이전 최소값'만 남길 수 있다.
    그리고 그 '이전 최소값'보다 현재 원소가 작으므로 기회 소모 없이 왼쪽을 모조리 제거할 수 있다.
    오른쪽에서도 가장 작은 원소를 남기고, 기회가 남아있으므로 현재 원소를 남길 수 있다.
    반대편부터 순회하면 대소 경우가 다르므로 그것도 체크해준다.
그렇게 순회한 원소들을 중복 제거한 후 개수를 세면 된다.
아이디어를 얻기까지 시간이 좀 오래 걸릴 수 있는 문제.  
"""

for inputdata in inputdatas:
    data, ans = inputdata["data"], inputdata["answer"]
    res = solution(*data)
    if res == ans:
        print("pass")
    else:
        summary = "fail"
        for label, content in [("expected:", ans), ("got:", res)]:
            summary += f"\n  {label}\n"
            summary += f"    {content}\n"
            summary = summary.rstrip()
        print(summary)
