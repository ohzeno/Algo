# https://school.programmers.co.kr/learn/courses/30/lessons/12899
"""
124 나라는 자신들만의 규칙으로 수를 표현함.
자연수만 존재하고 모든 수를 1, 2, 4로 표현함
10진법 - 124 나라
1 - 1
2 - 2
3 - 4
4 - 11
5 - 12
6 - 14
7 - 21
8 - 22
9 - 24
10 - 41
11 - 42
12 - 44

n이 주어지면 124 나라에서 사용하는 숫자로 바꿔서 리턴하라.
"""

# 3진 변환 후 0이 포함되는 경우만 후처리
def solution(n):
    def ten_to_3(n):
        if n == 0:
            return "0"
        s = ""
        while n > 0:
            n, r = divmod(n, 3)
            s += str(r)
        return s[::-1]

    def three_to_10(s):
        n = 0
        for i, c in enumerate(s[::-1]):
            n += int(c) * 3**i
        return n

    s = ten_to_3(n)
    if '0' in s:
        ns = ''
        while s and s != '0':
            if s[-1] == '0':
                ns += '4'
                fs = three_to_10(s[:-1]) - 1
                s = ten_to_3(fs)
            else:
                ns += s[-1]
                s = s[:-1]
        s = ns[::-1]
    return s


inputdatas = [
    {"data": [1], "answer": "1"},
    {"data": [2], "answer": "2"},
    {"data": [3], "answer": "4"},
    {"data": [4], "answer": "11"},
    {"data": [5], "answer": "12"},
    {"data": [6], "answer": "14"},
    {"data": [7], "answer": "21"},
    {"data": [8], "answer": "22"},
    {"data": [9], "answer": "24"},
    {"data": [10], "answer": "41"},
    {"data": [11], "answer": "42"},
    {"data": [12], "answer": "44"},
    {"data": [13], "answer": "111"},
    {"data": [14], "answer": "112"},
    {"data": [15], "answer": "114"},
    {"data": [16], "answer": "121"},
    {"data": [17], "answer": "122"},
    {"data": [18], "answer": "124"},
    {"data": [19], "answer": "141"},
    {"data": [20], "answer": "142"},
    {"data": [21], "answer": "144"},
]

"""
124 나라의 숫자
Lv.2. 현 시점 완료한 사람 24912명, 정답률 50%

Lv.2치고 상당히 어렵다. 
내가 본 모든 풀이들은 같은 로직을 사용한다.
내가 본 대부분의 답변은 질문도 로직도 이해 못하고 인덱싱을 위해 1을 뺀다고 한다.

인덱싱만을 위해서면 d를 '124'가 아니라 '412'로 두면 되는 일이다.
'124'로 두더라도 나머지를 이용해 인덱싱하므로 인덱싱 순간에만 1을 빼주면 된다.

0이 아니라 1부터 시작해서 1을 빼줘야 한다는 말들도 있었다(
    3진법 012 대응이 124나라의 124인데 
    10진법 012에 3진법 012가 대응되지만
    10진법 123에 124 나라 124가 대응되므로
)
그것도 말이 안된다.
그러면 처음에 한번만 n에서 1을 빼야지, while문 안에서 매번 n에서 1을 빼고 연산하면 안된다.
그러면 연산마다 -1이 누적될 테니까.

위 답변들이 사실이면 그냥 3진법으로 변환한 후에 replace로 해결할 수 있어야 한다.

하지만 실제 풀이들은 매 연산마다 n에서 1을 뺀 후 몫과 나머지를 구한다.
그러면 나머지 뿐 아니라 몫에도 영향이 간다. 그 영향은 다음 연산에도 미치고, 연산마다 누적된다.

이는 124나라의 규칙의 특이성 때문이다.
10진법 - 3진법 - 124나라 를 보자.
1 - 1 - 1
2 - 2 - 2
3 - 10 - 4
4 - 11 - 11
5 - 12 - 12
6 - 20 - 14
7 - 21 - 21
8 - 22 - 22
9 - 24 - 100
10 - 41 - 101
11 - 42 - 102
12 - 44 - 110
13 - 111 - 111
14 - 112 - 112
15 - 114 - 120
16 - 121 - 121
17 - 122 - 122
18 - 124 - 200
19 - 141 - 201
20 - 142 - 202
21 - 144 - 210

3진법 변환 후 0이 결과에 포함되지 않는다면 3진수와 124나라의 수가 같다.
즉, 3진수 변환 후 0이 포함되는 경우만 추가 처리를 해줘야 한다.
그리고, 3진수에 0이 포함된 경우를 살펴보자.
작은 자리부터 3진법의 0이 4로 대체되면서, 앞자리 삼진수에서 1이 빠진다.
3: 10 -> 1-1 + 4 -> 04
6: 20 -> 2-1 + 4 -> 14
9: 100 -> 10-1 + 4 -> 24
10: 101 -> 1-1 + 4 + 1 -> 41
11: 102 -> 1-1 + 4 + 2 -> 42
12: 110 -> 11-1 + 4 -> 10 + 4 -> 1-1 + 4 + 4 -> 44
15: 120 -> 12-1 + 4 -> 114
18: 200 -> 20-1 + 4 -> 124
...
21: 210 -> 21-1 + 4 -> 20 + 4 -> 2-1 + 4 + 4 -> 144
21의 경우를 보면 이 과정은 연쇄적으로 일어난다.

일단 직관적으로 그대로 구현한다면, 
3진법으로 변환부터 하고 0이 포함된 경우만 후처리를 해주면 된다.

그런데 이렇게 하면 효율성 테스트를 통과하지 못한다.
그럼 시간복잡도를 줄이기 위해 이걸 변환 과정 안에서 하도록 개선한다면?
21의 후처리 과정을 보면 뒷자리를 분리해가며 앞의 삼진수에서 1을 빼준다.
10진수에서 1을 빼고 3진수로 변환한 결과는 3진수에서 1을 뺀 결과와 같다.
10진수나 3진수나 표현 방법일 뿐 값이 같기 때문이다.
그러므로 변환 과정 중 r이 0일 때마다 몫(10진수)에서 1을 빼주는 것은
3진법 변환 후 후처리에서 0마다 앞자리(3진수)에서 1을 빼주는 것과 같은 결과를 도출한다.

그런데 풀이들 일부는 몫에서 1을 빼는게 아니라 n-1부터 하고 연산을 진행한다.
이는 divmod로 보면 이해하기 쉽다.
내 풀이는 divmod(n-1, 3)을 사용하는데, n-=1 이후 몫과 나머지를 구하는 것과 같은 로직이다.
그리고 divmod를 저렇게 사용하면 n(최초값만이 아닌 변환 도중의)이 
3의 배수인 경우마다(3진수 변환 결과에 0이 추가되는 경우마다) 몫이 1 줄어들어, 
기존에 r이 0일 때마다 몫에서 1을 빼주던 효과를 얻을 수 있다.

물론, 기존과 달리 나머지가 항상 1 줄어드는데, 이는 '124'를 인덱싱하면 해결된다.
원래 연산에서 나머지가 0, 1, 2일 때 4, 1, 2를 붙여줬었는데,
n-1 연산 후에는 나머지가 2, 0, 1이 되고, '124'에 인덱싱하면 4, 1, 2가 나온다.
그러므로 인덱싱 결과를 붙여주면 기존과 같다.

이걸 이해하고 푼 사람이 얼마나 될지 궁금하다.
"""

for inputdata in inputdatas:
    data, ans = inputdata["data"], inputdata["answer"]
    res = solution(*data)
    if res == ans:
        print("pass")
    else:
        summary = "fail"
        for label, content in [("expected:", ans), ("got:", res)]:
            summary += f"\n  {label}\n"
            summary += f"    {content}\n"
            summary = summary.rstrip()
        print(summary)
