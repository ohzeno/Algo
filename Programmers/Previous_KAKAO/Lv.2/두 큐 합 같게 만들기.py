# https://school.programmers.co.kr/learn/courses/30/lessons/118667
from collections import deque

def solution(queue1, queue2):
    # pop, insert를 1회 작업으로 취급
    # 각 큐의 원소의 합이 같도록 하기 위한 최소 작업 횟수
    # 어떻게 해도 각 큐의 원소 합을 같게 만들 수 없는 경우 -1 리턴
    # 큐의 길이: 1~30만    큐의 원소: 1~1억
    s1, s2 = sum(queue1), sum(queue2)  # 각 큐 합
    if (s1 + s2) % 2:  # 홀수면 2등분 안됨.
        return -1
    q1, q2 = map(deque, (queue1, queue2))
    n = len(q1) * 2  # 두 큐를 이어놓은 리스트에서 투포인터를 사용한다고 생각할 수 있다.
    limit = n * 4  # 상세는 주석 참고. a가 n만큼 움직이면 b도 n만큼만 움직일 수 있음.

    def shift_to(q1, q2):  # q1에서 q2로 옮기고 값 반환
        tmp = q1.popleft()
        q2.append(tmp)
        return tmp

    ans = 0
    while True:
        if s1 == s2:  # 같으면 횟수 반환.
            return ans
        if s1 > s2:  # s1이 크면 s1에서 s2로 옮기기
            val = shift_to(q1, q2)
            s1 -= val
            s2 += val
        else:  # s2가 크면 s1으로 옮기기
            val = shift_to(q2, q1)
            s1 += val
            s2 -= val
        ans += 1
        if ans > limit:  # 횟수 초과하면 이미 검사했던 부분.
            return -1


inputdatas = [
    [[3, 2, 7, 2], [4, 6, 5, 1]],
    [[1, 2, 1, 2], [1, 10, 1, 2]],
    [[1, 1], [1, 5]],
]

"""
2022 카카오 인턴십 기출. Lv.2.
방법이 생각 안난다. 41분에 초안 제출, 테케 4개 제외하고 다 시간초과.
기존에 매번 sum하던 코드 제거, 초기 합에서 val 연산하도록 수정. 조합 다 구해서 정답케이스 있나 체크하던 함수 제거.
가능한 경우의 수(두 큐의 원소들 2그룹으로 나누는 케이스. 실제로 가능한 케이스인진 모르겠다.) 넘는 경우 -1 리턴하도록 수정.
50분에 해당 코드 제출. 테케 1~8 통과 9~12 런타임에러 13~24 시간초과 25~27 통과, 28, 30 시간초과, 29 런타임에러
경우의 수 계산하지 않고 두 큐의 상태를 visited에 기록하도록 변형.
58분에 해당 코드 제출. 11~12, 15, 18~24, 28, 30 시간초과.
앞뒤 바뀐 경우 제거하도록 큐 상태 정렬해서 튜플로 기록해도 같은 결과.
tuple로 바꾸는 과정 자체에서 시간초과 발생하는 것으로 추정.
변형 과정에서 초기 상태로 돌아오면 리턴하도록 수정.
67분에 해당 코드 제출, 테케 11, 28 시간초과.
가능한 경우의 수는 nC2이나 큰쪽만 옮기므로 nC2/2로 제한해서 제출. 11, 28 시간초과.
임의로 2 지점을 뽑는 경우의 수는 nC2가 맞으나 구해야 하는 제약은 이동 횟수다.
q1과 q2를 이어붙여 리스트로 두고 각각의 범위를 포인터로 지정할 수 있다.
오른끝은 다른 왼쪽끝에 의해 정해지므로 2개의 포인터만 있으면 된다.
각 포인터는 겹치지 않아야 한다. 이어붙인 2n 크기의 q에서 0, 1 원소에 a, b 포인터가 있다고 가정하면
b포인터는 2n만큼 움직이면 제자리로 돌아온다. a포인터는 b포인터가 움직인 만큼만 움직일 수 있으므로 최대 이동 횟수는 4n이 된다.
b가 2로 움직이면 a는 1로만 움직일 수 있고, b가 3으로 움직이면 a는 2로 이동 가능하지만 이미 1에 있었으므로 횟수는 '1' 증가한다.
도중에 시간을 재지 않았는데 2시간 이상 사용했다. 해당 풀이 제출, 통과.
수학적으로 최대 이동 횟수를 구하기가 까다로운 문제인데 Lv.2에 있는 이유는, 별 생각 없이 제약을 건 사람들 때문일 것이다.
실제 풀이들을 보면 죄다 추측이거나 임의로 수치를 정했다. 수치를 증명 해야한다면 Lv.4는 되지 않았을까 한다.
삼성 IM테스트에 수학적으로 증명하기 굉장히 힘든 문제가 있었는데(그래서 처음 봤을 땐 난이도가 엄청나게 높다 생각했다)
그냥 일단 로직 짜보니 통과했던 것과 비슷한 케이스.
"""

for t in inputdatas:
    print(solution(t[0], t[1]))
