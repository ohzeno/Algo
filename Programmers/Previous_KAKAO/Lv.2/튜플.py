# https://school.programmers.co.kr/learn/courses/30/lessons/64065
def solution(s):
    # 중복되는 원소가 없는 튜플이 {}로 주어짐.
    # (1,2,3,4)면 {} 첫 원소는 {1} 마지막은 {1,2,3,4}
    # 원소 순서 바뀌기도 함.
    # {1,3,2,4}처럼 원소 내 원소 순서도 바뀔 수 있음.
    # 문자열로 주어짐.
    # 문자열이 나타내는 튜플을 배열로 리턴.
    datas = s[2:-2].split('},{')  # 앞뒤 중괄호는 인덱싱으로, 나머지는 스플릿으로 사라진다.
    datas = sorted(datas, key=lambda x: len(x))  # 길이대로 오름차순 정렬
    ans = []  # 정답 저장할 배열
    pre = set()  # 이전 차례와의 원소 비교를 위한 세트
    for data in datas:  # 각 문자열에 대해서
        tmp = set(data.split(',')) - pre  # 이전 세트와 비교하여 추가된 원소를 찾는다.
        ans.append(int(tmp.pop()))  # 세트에서 뽑아낸 원소를 숫자로 바꿔 추가한다.
        pre = set(data.split(','))  # 다음 세트와 비교를 위해 파싱된 현 세트를 저장한다.
    return ans

inputdatas = [
    '{{2},{2,1},{2,1,3},{2,1,3,4}}',
    '{{1,2,3},{2,1},{1,2,4,3},{2}}',
    '{{20,111},{111}}',
    '{{123}}',
    '{{4,2,3},{3},{2,3,4,1},{2,3}}'
]

"""
2019 카카오 개발자 겨울 인턴십 기출.
Lv2. 36분 걸렸다. 첫 로직은 15분쯤 걸린 것 같다.
쉬운 문제인데 테케 일부를 통과하지 못해 한참 헤맸다.
알고보니 pre에 파싱하지 않은 문자열을 그대로 할당해서 틀렸었다...
"""

for t in inputdatas:
    print(solution(t))
