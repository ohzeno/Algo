# https://school.programmers.co.kr/learn/courses/30/lessons/60061
# 2차 시도. 조건 깔끔해짐.
def solution(n, build_frame):
    """
    - 기둥은 바닥 위 or 보의 한쪽 끝 or 다른 기둥 위에 있어야 함
    - 보는 한쪽 끝 부분이 기둥 위 or 양쪽 끝 부분이 다른 보와 동시에 연결되어야 함.
    바닥은 맨 아래.
    삭제 기능도 있는데 삭제 후 규칙을 만족해야 함.
    벽면 크기 n, 작업이 담긴 2차원 배열 build_frame이 주어짐.
    모든 명령 수행 후 상태 return.
    명령은 [x, y, a, b]로 구성.
    x, y는 가로, 세로 좌표,
    a는 구조물 종류(0: 기둥, 1: 보),
    b는 설치/삭제(0: 삭제, 1: 설치)
    벽면을 벗어나게 설치하는 경우 없음. 바닥에 보 설치하는 경우 없음.
    보는 교차점 좌표 기준으로 오른쪽, 기둥은 위로 설치/삭제
    구조물 겹치도록 설치하는 경우 없음. 없는 구조물 삭제 없음.
    가로세로 3인 2차원 배열에 각 구조물 좌표 표시.
    return 배열의 원소는 [x, y, a]로 구성.
    return 배열은 x좌표 기준 오름차순. x좌표 같으면 y좌표 기준 오름차순.
    x, y 같으면 기둥이 보보다 앞.
    """
    def is_ok(x, y, a):
        if a == 0:  # 기둥인가?
            t1 = y == 0 or (x, y-1, 0) in answer  # 바닥이거나 아래에 기둥이 있나?
            t2 = (x-1, y, 1) in answer  # 왼쪽에 보가 있나?
            t3 = (x, y, 1) in answer  # 오른쪽에 보가 있나?
        else:  # 보인가?
            t1 = (x, y-1, 0) in answer  # 왼쪽 아래에 기둥이 있나?
            t2 = (x+1, y-1, 0) in answer  # 오른쪽 아래에 기둥이 있나?
            t3 = (x-1, y, 1) in answer and (x+1, y, 1) in answer  # 양쪽에 보가 있나?
        return t1 or t2 or t3  # 하나라도 만족하면 True
    answer = set()
    for x, y, a, b in build_frame:
        if b == 0:
            answer.remove((x, y, a))  # 일단 삭제
            if any(not is_ok(r, c, a2) for r, c, a2 in answer):  # 문제 있으면
                answer.add((x, y, a))
        elif is_ok(x, y, a):  # 설치 가능하면
            answer.add((x, y, a))  # 설치
    return sorted(answer)  # 정렬해서 반환

inputdatas = [
    # [
    #     9, [[2, 0, 0, 1], [9, 0, 0, 1], [9, 1, 1, 1], [8, 1, 1, 1], [8, 1, 0, 1], [8, 0, 0, 1]]
    # ],
    # [4, [[1, 0, 0, 1], [1, 1, 1, 1], [1, 1, 0, 1], [2, 1, 0, 1], [1, 2, 1, 1], [1, 1, 0, 0]]],
    # [5,
    #  [
    #      [1, 0, 0, 1],
    #      [1, 1, 1, 1],
    #      [2, 1, 0, 1],
    #      [2, 2, 1, 1],
    #      [5, 0, 0, 1],
    #      [5, 1, 0, 1],
    #      [4, 2, 1, 1],
    #      [3, 2, 1, 1],
    #  ]
    # ],
    [5,
     [
         [0, 0, 0, 1],
         [2, 0, 0, 1],
         [4, 0, 0, 1],
         [0, 1, 1, 1],
         [1, 1, 1, 1],
         [2, 1, 1, 1],
         [3, 1, 1, 1],
         [2, 0, 0, 0],
         [1, 1, 1, 0],
         [2, 2, 0, 1],
     ]
    ]
]

"""
2020 카카오 공채 기출. Lv.3.
초안은 88분 걸렸다. 오래걸린 이유 중 하나가, "구조물이 겹치도록 설치하는 경우는 주어지지 않는다"라는 말이 애매해서다.
기둥 위에 보와 기둥이 같이 올 수 있는 케이스를 생각했지만 예시에서는 없고 저런 문구가 있어서 
일단 교차점에서 기둥과 보과 겹치지 않는다고 가정하고 풀고 제출한 후에 확인해보기로 했다.
아니나 다를까 초안은 테케 6, 7만 통과했다. 
다시 보다보니 'x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.'가 있어서 기둥과 보가 겹칠 수 있다.
일부러 설명을 애매하게 하고 예외를 찾을 수 있나를 검증하는 문제같긴 한데...
보, 기둥이 겹칠 수 있을 가능성을 생각했음에도 그렇게 구현하지 않은 이유는,
보, 기둥이 겹치면 조건이 많아져 구현이 까다로워져 시간낭비가 심하기 때문이다.
결국 시간 아끼려다 시간을 더 낭비하게 됐다.
겹침을 허용하도록 32분 더 구현하였으나 테케 5, 6, 7만 통과했다. 
아무리 봐도 틀린게 없어서 다른 정답풀이와 내 풀이에 인풋값을 넣어보며 다른 경우를 찾았다.
'벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.'에 위배되는 케이스에서 내 풀이와 다른 풀이의 아웃풋이 달랐다.
다음날 풀이를 60분정도 살펴보다 오류를 찾았다. isok()의 기둥 케이스에서 현 좌표의 보를 체크해야 하는데 오른쪽 보를 체크했다... 3개 케이스랑 예시 2개 맞은게 용한 지경. 가장 기초적인 부분에서 실수를 한거라 좀 많이 당황스럽다.
다른 풀이를 보면 remove에서 나처럼 복잡하게 체크하지 않는다. build_frame의 길이가 1000, n이 100이 최대라는 점에 착안하여, 삭제 명령이 들어오면 일단 삭제 후 지금까지 설치된 좌표들을 일일이 순회하며 안정성 체크를 해주고, 문제가 있다면 복구한다. 나는 효율성체크가 없는 경우에도 시간초과를 많이 경험하여 그런 비효율적 방법을 시도하지 못했다. 하지만 구현난이도가 엄청나게 내려가므로 실제 시험에서는 그렇게 풀었어야 했을 듯 하다. 기존 풀이는 solution0으로, 해당 풀이는 solution으로 작성해놓았다.

2차시도. 39분만에 통과. 기존 첫 번째 풀이와 비슷하지만 더 깔끔하게 개선됐다.
기존 두 번째 풀이를 확인한 후 더 깔끔하게 작성했다. 20줄됨.
"""

for t in inputdatas:
    print(solution(t[0], t[1]))
